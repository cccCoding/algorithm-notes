区块链是一个去中心化，不可逆，不可纂改的分布式账本。 而共识算法就是用来解决区块链系统中一致性问题的算法机制。

**常见共识算法有**

PoW，PoS，DPoS，PBFT，Raft，DAG等。

其中PoW、PoS和DPoS是公有链常用的共识算法，最终一致性。PBFT和Raft是联盟链和私有链常用的共识算法，强一致性。

PoW、PoS、DPoS、PBFT容忍拜占庭错误，Paxos、Raft不容忍拜占庭错误。

**PoW**

工作量证明机制（Proof of Work），简单理解就是通过一份证明，用来确认你做过一定量的工作。举个例子，你读四年大学，拿到一个毕业证，这个毕业证就能证明你在某段时间某个大学完成了学业。

区块链中的工作量证明，基于哈希算法难题友好性（没有便捷的方法去产生一满足特殊要求的哈希值）。将区块头中版本号，上一个区块哈希，交易Merkle根哈希，时间戳，难度值，随机数nonce等作为输入进行哈希运算，通过不停变更随机数nonce直到结果hash值小于当前挖矿难度值。

弊端： 1，算力浪费   2，矿池的出现一定程度上违背了去中心的初衷，也使得51%攻击成为可能，存在安全隐患

**PoS**

权益证明机制（Proof of Stake），很大程度上因为PoW的缺陷而提出。节点产生区块难度和你在网络中所占股权相关。

以点点币为例，引入了币龄的概念，使得挖矿难度与交易输入的币龄成反比。消耗币龄获取利息，同时获得生成区块的优先权。

随机散列运算在一个有限制的空间内完成，而不像PoW那样在无限制的空间里寻找，减小能量消耗。

弊端：首富账户权力越来越大，有可能支配记账权。

**DPoS**

股份授权证明机制（Delegated Proof of Stake），旨在优化PoW和PoS中共识效率低和严重集中化问题。

以比特股为例，引入了见证人的概念，见证人可以生成区块，每个持有比特股的人都可以投票选举见证人。见证人的候选名单每个维护周期更新一次。然后见证人随机排列，每个见证人按序有2秒的权限时间来生成区块，若见证人在给定时间片不能生成区块，区块生成权限交给下一时间片对应的见证人。如果见证人提供的算力不稳定或计算机宕机，持股人可以通过投票更换这些见证人。

核心思想是缩小参与核心共识过程的节点数量，以提高共识效率。

**RAFT**

Raft是在非拜占庭故障下达成共识的强一致协议。在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权利管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。如果leader失效或与其他节点失去联系，这时，系统就会选出新的leader。

##### Raft基础

一个Raft集群通常包含5个服务器，允许系统有2个故障服务器。每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower。follower是被动的，不会对自身发出的请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader)。candidate状态用来选举leader。



Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。

##### leader选举过程

当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态。这个超时时间是一个150~300ms之间的随机数。

一般而言，在Raft系统中： 
1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。 
2）其他服务器同意了，发出OK。如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到N/2+1的大多数票，候选人还是可以成为leader。 
3）这样这个候选者就成为了leader领导人，它可以向follower发出指令，比如进行记账。 
4）以后可以通过心跳进行记账的通知。 
5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。 
6）follower同意后，其成为leader，继续承担记账等指导工作。

##### 记账过程

Raft的记账过程按以下步骤完成： 
1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求； 
2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中； 
3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功消息； 
4）在下一个心跳中，leader会通知所有follower更新确认的项目。 
对于每个新的交易记录，重复上述过程。

如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，它们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，新的leader的新更新。

论文原文：https://raft.github.io/raft.pdf

动画演示：http://thesecretlivesofdata.com/raft/
学习参考：https://raft.github.io/

**PBFT**

实用拜占庭容错算法是一种状态机副本复制算法，通过节点间的多轮消息传递，网络内的所有诚实节点能够达成共识。

PBFT系统通常假设故障节点数为m个，整个系统服务节点数为3m+1个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获取任何服务器运行的状态信息，PBFT中主节点是否发生错误只能由服务器检测。如果服务在一段时间内都不能完成客户端的请求，则会触发视图更换协议。

![img](https://vipkshttps10.wiz.cn/ks/note/view/d77f8911-0dc3-4f54-8d2e-5b4cb9b7cb31/3c9e3dbd-c399-454d-b38d-38697c722429/index_files/1160773-670f70bcaeb0eca4.png)

参数定义

client：客户端，发出调用请求的实体view：视图，内容为连续的编号replica：网络节点primary：主节点，负责生成消息序列号backup：支撑节点，辅助整体共识过程state：节点状态

PBFT算法要求整个系统流程在同一个视图下完成，所有节点采取一致的行动。通过三阶段协议来使所有正常节点按相同的顺序执行请求，三阶段分别为pre-prepare，prepare，commit阶段。pre-prepare阶段和prepare阶段用来把同一个view里发送的请求排序，然后让各个replicas节点都认可这个排序，照序执行。prepare阶段和commit阶段用来确保那些已经达到commit状态的请求即使在发生视图改变后，在新的view里依然保持原有的序列不变。而处于pre-prepare阶段和prepare阶段的请求在view change发生后，在新的view里都将被遗弃。

pre-prepare阶段

主节点分配一个编号n给收到的请求，然后向所有备份节点广播pre-prepare信息，预准备消息的格式为<<PRE-PREPARE,v,n,d>,m>，这里v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要。备份节点在进行签名、视图编号等一系列验证后，接受这条信息。当一个备份节点接受了这条信息后，则进入prepare阶段。

prepare阶段

一个节点进入到自己的prepare阶段后，开始将一条prepare信息<PREPARE,v,n,d,i>广播给主节点和其他的备份节点。与此同时，该备份节点也会收到来自其他备份节点的prepare信息，在收到prepare消息后，进行一系列验证，当一个备份节点从超过2/3节点收到与预准备消息一致且通过验证的准备消息时，那么我们就说该请求在这个节点上的状态是prepared。

commit阶段

一个节点进入commit阶段后，他会广播一条commit信息给其他所有节点告诉他们它已经prepared。与此同时它也会陆续收到来自其他节点的commit信息，如果它收到了超过2/3节点数的验证与预准备消息一致的commit信息后，我们就说请求在这个节点上达到了commited状态，该节点会执行这条请求，并向客户端响应。

当客户端收到m+1个相同响应，则该响应为运算的结果。